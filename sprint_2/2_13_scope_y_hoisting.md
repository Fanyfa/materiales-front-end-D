# Scope y hoisting

<!-- TOC START min:4 max:4 link:true update:true -->
- [EJERCICIO 1](#ejercicio-1)
- [EJERCICIO 2](#ejercicio-2)
- [EJERCICIO 3](#ejercicio-3)
- [EJERCICIO 4](#ejercicio-4)

<!-- TOC END -->



## Introducci√≥n

A medida que vamos aprendiendo m√°s y m√°s JavaScript, es necesario que vayamos profundizando en conceptos un poco m√°s t√©cnicos pero que es fundamental que entendamos. Estos conceptos nos ayudar√°n a entender c√≥mo funciona JavaScript a m√°s bajo nivel y nos har√°n que captemos mejor el funcionamiento de un c√≥digo y, por tanto, sepamos resolver mejor los errores que se producen y creemos un c√≥digo m√°s estable y mejor estructurado.

En esta sesi√≥n veremos, en primer lugar, qu√© es el √°mbito (scope) de las variables y funciones y aprenderemos a fondo c√≥mo funciona para tenerlo en cuenta a la hora de ver d√≥nde declarar variables y funciones en nuestro c√≥digo.

Tambi√©n veremos qu√© es el hoisting (que no tiene nada que ver con hosting :) ) y que describe c√≥mo reorganiza el int√©rprete de JavaScript (nuestro navegador web) el c√≥digo antes de ejecutarlo.


## ¬øPara qu√© sirve lo que vamos a ver en esta sesi√≥n?

Hasta ahora hemos establecido una serie de normas porque s√≠, como que siempre tenemos que declarar una variable antes de usarla o que las funciones las podemos definir despu√©s de utilizarlas. Tambi√©n hemos comentado que las variables que creamos fuera de una funci√≥n pueden usarse dentro de esta y, sin embargo, las que creamos dentro de una funci√≥n no pueden ser utilizadas fuera de esta.

El hecho es que solo hemos definido reglas para esto y no hemos explicado el porqu√© detr√°s de cada una de ellas. Lo que vamos a ver en esta sesi√≥n nos ayudar√° a saber el por qu√© y a conocer cu√°l es el proceso que se produce en nuestro navegador y que influye en ese comportamiento.


## ¬øEn qu√© casos se utiliza?

Dado que todo lo que vamos a ver es algo relacionado con c√≥mo funciona JavaScript, nos ser√° √∫til en todo momento debido a que estos conceptos forman parte de la naturaleza de este lenguaje.

Aprender este tipo de conceptos un poco m√°s avanzados te aportar√° conocimientos clave a la hora de empezar a trabajar con JavaScript y a obtener una base s√≥lida y unos conocimientos que van m√°s all√° de generar c√≥digo sin saber las reglas que caracterizan la estructura, entender el por qu√© detr√°s de ciertas buenas pr√°cticas.


## √Åmbito o scope

Bien, vamos a empezar entendiendo mejor qu√© es el scope o el √°mbito, para ello lo mejor es ponernos en situaci√≥n, entender c√≥mo es el proceso que se lleva a cabo en nuestro navegador para entender qu√© sucede con el c√≥digo de JavaScript que generamos y c√≥mo este es ejecutado.

En primer lugar, hay que dejar claro que no vamos a ver en detalle qu√© sucede desde que se lee el c√≥digo JavaScript hasta que se ejecuta. Pero vamos a pensar como si fu√©semos el int√©rprete de JavaScript, la parte de nuestro navegador encargada de entender JavaScript y saber qu√© hacer con el c√≥digo.

Bien, imaginemos que tenemos el siguiente c√≥digo:

```js

var greeting = 'Hola';

function sayHello() {
  var greeting = 'Hello';
  console.log(greeting);
}

sayHello();
```

>Como puedes ver, este c√≥digo no tiene ninguna l√≥gica, simplemente es algo sencillo para que nos sirva de ejemplo.

¬øSabr√≠as adivinar que va a mostrar? Pi√©nsalo detenidamente (no vale ejecutar el c√≥digo üëÆüèª‚Äç‚ôÄÔ∏è).

Bien, antes de saber cu√°l ser√° el resultado, vamos a ver qu√© pasos sigue este c√≥digo.

JavaScript en este caso realiza los siguientes pasos:
1. Genera la variable `greeting` en el √°mbito global y posteriormente le asigna `Hola`
1. Declara una funci√≥n (crea la funci√≥n)
1. Ejecuta la funci√≥n sayHello
1. Al ejecutar la funci√≥n `sayHello` y por tanto el c√≥digo que contiene, se crea una variable `greeting` en el √°mbito de la funci√≥n `sayHello`
1. Se ejecuta el `console.log`, en este caso como le hemos pasado como argumento la variable `greeting`, buscar√° esa variable en el √°mbito m√°s pr√≥ximo y utilizar√° el valor que almacena

Bien, la clave en estos pasos reside en una palabra, √°mbito. Hemos hablado de √°mbito de la funci√≥n, √°mbito global y √°mbito m√°s pr√≥ximo, pero ¬øqu√© es el √°mbito?. En JavaScript, el √°mbito se encarga de llevar la lista de todas las variables y funciones declaradas y define una serie de reglas que establecen si esas variables son accesibles en el momento de ejecutar un c√≥digo. Dentro de nuestro c√≥digo podremos tener distintos √°mbitos, cada uno con una serie distinta de variables a las que podemos acceder.

En JavaScript, la √∫nica forma de generar un nuevo √°mbito es creando una funci√≥n. Dentro de esta todo lo que definamos (variables o funciones) estar√° encapsulado y solo se podr√° acceder desde dentro de la funci√≥n, desde su √°mbito, fuera de este ser√° como si no existiese.

>NOTA: en realidad es mentira que la √∫nica forma de crear un nuevo √°mbito en JavaScript es a trav√©s de las funciones. Existe otra manera para crear un nuevo √°mbito en la versi√≥n que estamos utilizando de JavaScript pero no la vamos a ver en este curso. S√≠ que veremos m√°s adelante, una nueva forma de crear √°mbitos en la nueva versi√≥n de JavaScript, pero por el momento pensemos que solo se puede generar un nuevo √°mbito usando funciones.

Por lo tanto, cada vez que creemos una nueva funci√≥n estaremos generando a la par un nuevo √°mbito. Todo lo que est√© fuera de funciones y se defina directamente en el c√≥digo, pertenecer√° al denominado √°mbito global, que es el que engloba todo nuestro c√≥digo y es accesible desde cualquier parte.

Como esto puede ser un poco lioso, vamos a ilustrar cu√°les ser√≠an los √°mbitos en el ejemplo anterior, c√≥mo funcionan y c√≥mo se modifican en cada paso.

Bien, volviendo a los pasos anteriores, vamos a ilustrar cada uno de ellos para ver que sucede en cada uno de ellos:

### 1. Genera la variable `greeting` en el √°mbito global y posteriormente le asigna `Hola`

En este paso a√±adimos al *scope* global una variable `greeting` y guardamos el valor de `Hola` dentro de ella. El √°mbito global abarcar√≠a todo el c√≥digo, como hemos comentado anteriormente, si generamos una variable o funci√≥n en el scope global esta podr√° ser usada en cualquier parte de nuestro JavaScript, de ah√≠ que el alcance de este scope (donde se pueden utilizar las variables y funciones creadas en √©l) se extienda a todo el c√≥digo.

### 2. Declara una funci√≥n (crea la funci√≥n)

Al crear la funci√≥n `sayHello`, generamos un nuevo √°mbito, por lo que todas las variables que se creen dentro de la funci√≥n ya no estar√°n incluidas en el √°mbito global, sino en el de esta funci√≥n. Lo mismo sucede con los par√°metros, que estar√°n incluidos en el √°mbito.

### 3. Al ejecutar la funci√≥n `sayHello` y por tanto el c√≥digo que contiene, se crea una variable `greeting` en el √°mbito de la funci√≥n `sayHello`

Bien, hemos creado una variable y la hemos creado dentro de `sayHello`. En el momento de crearla, esta se a√±adir√° al scope de la funci√≥n.

### 4. Se ejecuta el `console.log`, en este caso como le hemos pasado como argumento la variable `greeting`, buscar√° esa variable en el √°mbito m√°s pr√≥ximo y utilizar√° el valor que almacena

Bien, este es una de las partes clave para entender c√≥mo funciona el scope. En esta parte del c√≥digo estamos utilizando la variable `greeting` para poder utilizar el valor que almacena y por tanto, que este se muestre en el `console.log`. ¬øQu√© hace JavaScript en este caso? Pues muy simple, busca si esa variable existe en el √°mbito actual y sino en el √°mbito que est√° por encima y sino en el de encima de ese y as√≠ continuamente.

En este caso busca en el √°mbito actual, como el c√≥digo se est√° ejecutando dentro de la funci√≥n `sayHello`, el √°mbito actual ser√° el √°mbito de la funci√≥n, por lo que en primer lugar buscar√° ah√≠ si existe la variable que necesita (`greeting`). Como s√≠ existe ah√≠, utiliza esa variable para coger el valor y por tanto, como en este caso el `greeting` de dentro de la funci√≥n guarda `'Hello'`, se sustituir√° por ese texto y el `console.log` mostrar√° `'Hello'`.

Si en este caso no hubi√©semos declarado una variable `greeting` en la funci√≥n, al ejecutar el c√≥digo, el int√©rprete de JavaScript (el navegador) buscar√≠a esa variable en el √°mbito de `sayHello` y al no encontrarla ir√≠a subiendo en √°mbitos. En ese caso ir√≠a directamente al √°mbito global porque es el √∫nico por encima de `sayHello` y tratar√≠a de buscar ah√≠ la variable. Como ese scope tiene una variable `greeting` definida, utilizar√° esa y por tanto en este caso el `console.log` mostrar√° `'Hola'`.

Si tras buscar en todos los √°mbitos que afectan a un c√≥digo no se encuentra ninguna variable que coincida con la utilizada, se producir√° un error de JavaScript llamado `ReferenceError` porque no encuentra la referencia a la variable utilizada, no encuentra ning√∫n sitio donde se haya declarado esa variable y por tanto hay un error de referencia (porque la referencia no existe).

El scope es algo que no podemos ver pero que debemos tener en cuenta y entender para prever cu√°l ser√° el resultado de nuestro c√≥digo. Es un proceso que no vemos pero est√° ah√≠ y existe e influye en c√≥mo se ejecuta el c√≥digo.

## Consultar el scope en las Chrome DevTools

Por √∫ltimo, podemos saber cual es el scope local y global en un momento determinado utilizando la pesta√±a sources de las Chrome Dev Tools. Esta pesta√±a sirve para depurar nuestro c√≥digo JavaScript y comprobar qu√© est√° haciendo en cada paso. En ella nos aparece un panel a la izquierda de la pantalla con la estructura de carpetas de la p√°gina. Si no nos aparece el panel, tenemos que pulsar en el icono con la flecha que apunta hacia la derecha, situado justo debajo del icono con el rat√≥n.

>Vista por defecto de la pesta√±a de _Sources_ de las Chrome DevTools

![Pesta√±a de _Sources_ de las herramientas de desarollo de Chrome](assets/images/3-6/empty-devtools-sources-tab.png)

A continuaci√≥n seleccionaremos el archivo JavaScript que queremos depurar dentro de la estructura de carpetas y nos mostrar√° el c√≥digo del archivo.

>Vista con un archivo abierto.Pesta√±a de _Sources_ de las herramientas de desarollo de Chrome

![Pesta√±a de _Sources_ con un archivo abierto](assets/images/3-6/devtools-sources-tab.png)

Para comprobar cu√°l es el scope en un momento determinado de la ejecuci√≥n de nuestro c√≥digo, simplemente pulsamos en el n√∫mero de una l√≠nea de c√≥digo para generar una parada en el c√≥digo (breakpoint), al pulsar sobre el n√∫mero aparecer√° un marcador azul para indicarnos que hemos generado una parada.

>C√≥digo con un breakpoint para parar la ejecuci√≥n en una l√≠nea determinada

![C√≥digo con un breakpoint para parar la ejecuci√≥n en una l√≠nea determinada](assets/images/3-6/how-to-add-breakpoint-sources.png)

Despues de generar una parada en el c√≥digo, recargamos la p√°gina. Al recargarla ejecutar√° el c√≥digo JavaScript hasta la linea en la que hemos puesto el breakpoint, donde se parar√° hasta que le digamos que continue.

>Vista del c√≥digo parado en un punto determinado

![Vista del c√≥digo parado en un punto determinado](assets/images/3-6/javascript-execution-paused.png)

En este momento podemos ver a la derecha un panel con una secci√≥n que tiene el nombre de scope. Dentro de esta podremos ver otras dos subsecciones, local y global. Local har√° referencia al scope local (si se est√° ejecutando una funci√≥n, ser√° al scope de la funci√≥n) y global har√° referencia al scope global, a todas las variables y funciones disponibles a lo largo de todo nuestro c√≥digo (tanto las que hemos creado nosotros como las que genera por defecto el navegador). El scope que se muestra ser√° el que haya justo en el momento antes de ejecutar la linea de c√≥digo en la que hemos realizado la parada.

>Vista de la secci√≥n scope en el panel de info de Sources

![Vista de la secci√≥n scope en el panel de info de Sources](assets/images/3-6/scope-section.png)

Y hasta aqu√≠ ser√≠a la descripci√≥n de qu√© es el scope o √°mbito en JavaScript. Si no te ha quedado todo perfectamente claro y no lo has pillado a la primera no te preocupes, este concepto es algo que a veces cuesta m√°s, la idea es explicarlo y que, a base de consultarlo y volver de vez en cuando a esta explicaci√≥n se llegue a un punto de entendimiento del concepto. Por el momento, con entender que el scope determina el alcance de nuestras variables y funciones y como funciona a grandes rasgos es m√°s que suficiente. La pr√°ctica y repaso a base de constancia con el c√≥digo har√°n el resto para entender a fondo de qu√© se trata.


* * *

#### EJERCICIO 1

**Averigua el resultado**

A continuaci√≥n vamos a poner una serie de c√≥digos. Estos no tienen un sentido l√≥gico m√°s all√° de practicar con lo aprendido sobre el scope. Sin ejecutarlos, intenta averiguar qu√© se mostrar√° en el `console.log` de cada uno de ellos.

>NOTA: Los ejercicios son parecidos pero cada uno de ellos tiene una modificaci√≥n. Lo mejor es leer paso a paso que hace cada uno aunque ya lo hayamos le√≠do antes para saber cu√°l ser√° el proceso que realicen.

```js
var message = 'El resultado ser√° A';

function changeMessage() {
  message = 'El resultado ser√° B';
}

changeMessage();

console.log(message);
```

```js
var message = 'El resultado ser√° A';

function changeMessage() {
  message = 'El resultado ser√° B';
}

console.log(message);
```

```js
var message = 'El resultado ser√° A';

function changeMessage() {
  var message = 'El resultado ser√° B';
}

changeMessage();

console.log(message);
```

Una vez hayas intentado averiguar cu√°l es el resultado de estos c√≥digo, comprueba si has acertado o no ejecut√°ndolos en tu navegador.

* * *

#### EJERCICIO 2

**Aprendiendo a averiguar el scope con las Dev Tools**

Abre tu ejercicio de evaluaci√≥n individual del segundo sprint (el de adivinar el n√∫mero aleatorio) y despu√©s abre el panel de las Chrome Dev Tools. Selecciona la pesta√±a _Sources_, coloca algunas paradas en el c√≥digo pulsando en los n√∫meros de l√≠nea del editor de c√≥digo que aparece. Recarga la p√°gina para que se vaya parando en cada una de las l√≠neas y comprueba en el panel derecho cual es el scope en cada caso.

Prueba a poner paradas tanto dentro de funciones como fuera para ver qu√© sucede.

* * *

## Hoisting

Como hemos visto hasta ahora, JavaScript genera √°mbitos para determinadas partes de nuestro c√≥digo, una cosa que hace para que la tarea de generar esos √°mbitos sea m√°s r√°pida es que todas las declaraciones (cuando creamos una variable o una funci√≥n) se "mueven" al principio de su √°mbito respectivo, esto es a lo que llamamos _hoisting_.

Imaginemos que tenemos el siguiente c√≥digo:

```js
var lower = 1;
var upper = 100;

function getRandomNumber(min, max) {
  console.log('Vamos a crear un n√∫mero random');

  var message = 'Se ha generado un n√∫mero aleatorio: ';
  var result = Math.floor((Math.random() * (max - min)) + min);

  console.log(message + result);

  return result;
}

console.log('Mensaje est√∫pido');

var randomNumber = getRandomNumber(lower, upper);
```

JavaScript cambiar√° el orden del c√≥digo y lo dejar√° de la siguiente forma:

```js
var lower;
var upper;
var randomNumber;

function getRandomNumber(min, max) {
  var message;
  var result;

  console.log('Vamos a crear un n√∫mero random');

  message = 'Se ha generado un n√∫mero aleatorio: ';
  result = Math.floor((Math.random() * (max - min)) + min);

  console.log(message + result);

  return result;
}

lower = 1;
upper = 100;

console.log('Mensaje est√∫pido');

randomNumber = getRandomNumber(lower, upper);
```

Como se puede ver, lo que hace b√°sicamente es mover las declaraciones de funciones y variables al principio del scope. Esto se ve muy claro si nos fijamos en que la declaraci√≥n de variables se han colocado antes que la ejecuci√≥n de los `console.log`.

¬°OJO! En el caso de las variables, solo se se aplica el hoisting a la declaraci√≥n (`var lower`) haciendo que esta se coloque al principio del c√≥digo. La asignaci√≥n (`lower = 1`) no se mueve, por eso siempre se recomienda que antes de usar una variable siempre la declaremos y asignemos, para que en el momento de usarla ya tenga un valor definido.

Saber esto nos ayuda a entender varias cosas:

- Las funciones siempre se van a mover arriba, por lo que da igual d√≥nde las declaremos (antes o despu√©s de usarlas) siempre podremos usarlas donde queramos
- Las declaraci√≥n de variables siempre se "mueve" arriba, pero la asignaci√≥n no. Debemos tener cuidado de siempre crear y asignar una variable antes de usarla
- JavaScript realiza una serie de operaciones antes de ejecutar el c√≥digo, estas le facilitan el trabajo y optimizan la ejecuci√≥n del c√≥digo

* * *

#### EJERCICIO 3

**Comprobando c√≥mo se aplica el hoisting con las Chrome Dev Tools**

Abre tu ejercicio de evaluaci√≥n individual del segundo sprint (el de adivinar el n√∫mero aleatorio). Pon una parada en el c√≥digo y comprueba si las variables se han a√±adido al scope para ver c√≥mo JavaScript aplica el _hoisting_.

* * *

#### EJERCICIO 4

**Detectando fallos en las declaraciones de variables**

A continuaci√≥n vamos a poner una serie de c√≥digos, algunos de ellos tendr√°n un error debido a que hemos usado/modificado una variable en un √°mbito que no est√° definido. Averigua cu√°les de estos c√≥digos son los que tienen un error e intenta razonar el por qu√©.

>NOTA: Estos c√≥digos no tienen un sentido l√≥gico m√°s all√° de practicar con lo aprendido sobre el scope

```js
'use strict';

var message = '¬°Hola!';
function showMessage() {
  console.log(message);
}
```

```js
'use strict';

function showMessage() {
  console.log(message);
}

var message = '¬°Hola!';
```

```js
'use strict';

var message;

function showMessage() {
  console.log(message);
}

message = '¬°Hola!';
```

```js
'use strict';

message = '¬°Hola!';

function showMessage() {
  console.log(message);
}
```

```js
'use strict';

function showMessage() {
  message = '¬°Hola!';
  console.log(message);
}

var message;
```

* * *
